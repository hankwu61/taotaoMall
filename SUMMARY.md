# Summary

* [MES分析設計書V1.0](README.md)
* [LANGUAGES USED](languages_used.md)
* [ASP.NET:](aspnet.md)
* [COMPARISON OF ASP AND ASP.NET:](comparison_of_asp_and_aspnet.md)
* [Client server means that SQL Server is designed to store data in the central location (the server) and deliver it on demand to numerous other locations (the client). SQL Server is also a Relational Database Management System (RDBMS).](client_server_means_that_sql_server_is_designed_to.md)
* [INTRODUCTION:](introduction.md)
* [Operational Feasibility](operational_feasibility.md)
* [DATABASE DESIGN:](database_design.md)
* [Data Integration ](data_integration.md)
* [Data Integrity](data_integrity.md)
* [Data Independence](data_independence.md)
* [The databases are implemented using a DBMS package. Each particular DBMS has unique characteristics and general techniques for Database Design.](the_databases_are_implemented_using_a_dbms_package.md)
* [In database design, several views of data must be considered along with the persons who use them. In addition to data structuring, where relationships are reflected between and within entities, we need to identify the application program’s logical views of data within an overall logical data structure. The logical view is what the data look like, regardless of how they are stored. The physical view is the way data exist in physical storage. It deals with hoe data are stored, accessed, or related to other data in storage. ](in_database_design,_several_views_of_data_must_be_.md)
* [The schema is the view that helps the DBMS decide in storage act upon as requested by the application program.](the_schema_is_the_view_that_helps_the_dbms_decide_.md)
* [CODE DESIGN](code_design.md)
* [The ability to interrupt codes, evaluate coding schemes and devices new or improved codes are important skills for a system analyst. Common types of codes are:](the_ability_to_interrupt_codes,_evaluate_coding_sc.md)
* [ A sequence code has no relation to the characteristics of an item. Here a dictionary is required. The data is arranged alphabetically and numbered sequentially. When a new data item is added it is given the next sequence number. The advantage of this code is that it has the ability touched with an unlimited number of digits.](a_sequence_code_has_no_relation_to_the_characteris.md)
* [SIGNIFICANT DIGIT CODE:](significant_digit_code.md)
* [Here, the item are specified by the user of letter and number combinations,](here,_the_item_are_specified_by_the_user_of_letter.md)
* [SELF CHECKING CODE:](self_checking_code.md)
* [VALIDATION CHECKS:](validation_checks.md)
* [Sometimes incorrect data can actually cause a computer system to stop work temporarily. This is a particular problem in batch processing systems when data may be processed overnights. If incorrect data stops a batch processing systems for working then a whole night processing time may be lost.](sometimes_incorrect_data_can_actually_cause_a_comp.md)
* [People who develop computer systems go to a lot of trouble to make it difficult for incorrect data to be entered. The two main techniques used for this purpose are:](people_who_develop_computer_systems_go_to_a_lot_of.md)
* [Verification:](verification.md)
* [Methods of Verification:](methods_of_verification.md)
* [On-Screen prompts: After a user has entered some data it is redisplayed on the screen. The user is prompted to read the data and confirm that it has been entered correctly. If the user has entered any data incorrectly he should response that the data is inaccurate and retypes the incorrect parts.](on-screen_prompts_after_a_user_has_entered_some_da.md)
* [A validation check is an automatic check made by computer to ensure that any data entered into the computer is sensible. A validation check does not make sure that data has been entered correctly. It only ensures that data is sensible. For this reason validation checks are not usually as effective as verification checks. They can however be carried out automatically by the computer and therefore require less work by the computer operators making them cheaper to use.](a_validation_check_is_an_automatic_check_made_by_c.md)
* [Methods of validation:](methods_of_validation.md)
* [Presence Checks: checks that data has been entered into the field and that it has not been left blank, e.g. checks that Project ID is always entered into each record in a database of project details.](presence_checks_checks_that_data_has_been_entered_.md)
* [Length Checks: checks that an entered value, e.g. Project ID is no longer than a particular number of characters.](length_checks_checks_that_an_entered_value,_eg_pro.md)
* [DATA DICTIONARY:](data_dictionary.md)
* [A data dictionary has many advantages. The most obvious is documentation; it is valuable reference in any organization. Another advantage is improving analyst/user communication by establishing consistent definition of various elements, terms and procedures. During implementation, it serves as a common base against which programmers who are working on the system compare data description. Also control information maintained for each data element is cross referenced in the data dictionary. E.g. program that use a given data element are cross referenced in a data dictionary, which makes it easy to identify them and make any necessary changes. Finally, a data dictionary is an important step in building a database. Most database management system has a data dictionary as a standard feature.](a_data_dictionary_has_many_advantages_the_most_obv.md)
* [INPUT DESIGN:](input_design.md)
* [The input design is the link between the information system and the user. It comprises developing specification and procedure for data preparation and those steps that are necessary to put transaction data into a usable form for processing data entry. The activity of putting data into the computer for processing can be achieved by instructing the computer to read data from a written or printed document or it can occur by having people key data directly into the system. The design of inputs focuses on controlling the amount of inputs required, controlling errors, avoiding delay, avoiding extra steps and keeping the process simple.](the_input_design_is_the_link_between_the_informati.md)
* [SYSTEM TESTING](system_testing.md)
* [INTRODUCTION:](introduction.md)
* [System testing was conducted in order to detect errors and for comparing then the final system with the requirement specification reports, i.e. whether the system meets requirements. During testing the software was executed with the set of test cases and the output of programs for the test cases was evaluated to determine if the program is performing as it was expected to.](system_testing_was_conducted_in_order_to_detect_er.md)
* [Testing presents an interesting challenge for the software engineers attempt to build software from an abstract concept to an acceptable implementation. In testing engineer create a series of test cases that occurs when errors are uncovered. Testing is the process of executing a program for finding errors. A good test is one that has the high probability of finding an uncovered error. A successful error is one that uncovers undiscovered errors.](testing_presents_an_interesting_challenge_for_the_.md)
* [The term error is used to refer the difference between actual output of the software and the current output. Fault is a condition that causes the software to fail to perform its required function. Software reliability is defined as a required function. Software reliability is defined as the probability that the software will not undergoes failures for a specified times under specified condition. Failure is the inability of a system or a component to perform a required function according to its specification. Different levels of testing were employed for software to make it error free, fault free and reliable.](the_term_error_is_used_to_refer_the_difference_bet.md)
* [Unit Testing:](unit_testing.md)
* [Unit testing was conducted first. Different modules of the software were tested against the specifications produced during design of the modules. Verification of the code produced during the coding phase was done. Each module was tested separately.](unit_testing_was_conducted_first_different_modules.md)
* [Unit testing focuses verification effort on the smallest unit of software design module. This uncovers errors within the boundary of a module. Unit testing is actually White box testing both the external things as well as the internal codes are tested. In testing, the interfaces are tested in order to ensure the proper flow of data in and out of the module. The boundary testing is done to ensure that the module keeps the limit of it. All independent paths are tested to ensure that all statements are tested at least once. At last the error path is also tested.](unit_testing_focuses_verification_effort_on_the_sm.md)
* [Unit testing comprises the set of tests performed by an individual programmer prior to integration of the unit into a larger system. There are four categories of test that can be performed on a program unit](unit_testing_comprises_the_set_of_tests_performed_.md)
* [Functional Unit](functional_unit.md)
* [Stress Unit](stress_unit.md)
* [Then system testing was conducted. Here the entire software system was tested.](then_system_testing_was_conducted_here_the_entire_.md)
* [System testing includes the thorough testing of the product. System testing is actually a series of different tests whose primary purpose is to fully exercise the computer based system. The tests are recovery testing: this checks the recovery of the system when failure occurs. This is to ensure that there are recovery procedures for error occurrences.](system_testing_includes_the_thorough_testing_of_th.md)
* [Prepare test plan](prepare_test_plan.md)
* [Prepare test data for program testing](prepare_test_data_for_program_testing.md)
* [Plan user testing](plan_user_testing.md)
* [Prepare job performance aids](prepare_job_performance_aids.md)
* [Prepare operational documents](prepare_operational_documents.md)
